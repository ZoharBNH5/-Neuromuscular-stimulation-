# -*- coding: utf-8 -*-
"""מעבדה 5 חדש.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-eEWt8eLADq4QH4wFCk8y2joOygcE-ph

ניסוי 1
"""

import scipy.io
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# רשימת קובצי ה-MAT
mat_files = [
    "ayelet_25v.mat",
    "ayelet_30v.mat",
    "ayelet_35v.mat",
    "ayelet_40v.mat"
]

# קצב הדגימה (הנחה: 2000 דגימות לשנייה)
sampling_rate = 2000  # 2000 Hz

# חלון זמן לסגמנטציה
pre_pulse = int(0.1 * sampling_rate)  # 100 מילישניות לפני הגירוי
post_pulse = int(0.4 * sampling_rate)  # 400 מילישניות אחרי הגירוי

# משתנה לאחסון תוצאות ROM מכל הקבצים
rom_results = []

for file in mat_files:
    # טעינת נתוני הקובץ
    mat_data = scipy.io.loadmat(file)
    data = mat_data['data']
    labels = mat_data['labels']

    # זיהוי ערוצי המדידה
    finger_displacement_idx = np.where(labels == 'Finger Displacement')[0][0]
    analog_input_idx = np.where(labels == 'Analog input')[0][0]

    # נתוני המדידה
    analog_signal = data[:, analog_input_idx]
    finger_signal = data[:, finger_displacement_idx]

    # זיהוי רגעי הפולסים
    threshold = np.mean(analog_signal) + 3 * np.std(analog_signal)
    pulse_starts = np.where((analog_signal[:-1] < threshold) & (analog_signal[1:] >= threshold))[0]

    # יצירת מקטעים סביב הפולסים
    segments = []
    for start in pulse_starts:
        if start - pre_pulse >= 0 and start + post_pulse < len(finger_signal):
            segments.append(finger_signal[start - pre_pulse:start + post_pulse])

    segments = np.array(segments)

    # חישוב ממוצע וסטיית תקן של הסגמנטים
    mean_response = np.mean(segments, axis=0)
    std_response = np.std(segments, axis=0)

    # חישוב ROM לכל פולס (ההבדל בין הערך המקסימלי לבין הערך ב-100ms לפני הגירוי)
    rom_values = np.max(segments, axis=1) - segments[:, pre_pulse]
    rom_mean = np.mean(rom_values)
    rom_std = np.std(rom_values)

    # שמירת הנתונים עבור הקובץ
    rom_results.append({"File": file, "Mean ROM": rom_mean, "Std ROM": rom_std, "Num Pulses": len(pulse_starts)})

    # יצירת גרף של ממוצע התגובה
    time_axis = np.linspace(-100, 400, pre_pulse + post_pulse)
    plt.figure(figsize=(8, 5))
    plt.plot(time_axis, mean_response, label='Mean Response', color='b')
    plt.fill_between(time_axis, mean_response - std_response, mean_response + std_response, color='b', alpha=0.2)
    plt.axvline(0, color='r', linestyle='--', label='Pulse Start')
    plt.xlabel('Time (ms)')
    plt.ylabel('Finger Displacement (cm)')
    plt.title(f'Average Finger Twitch Response - {file}')
    plt.legend()
    plt.show()

    # יצירת גרף של טווחי התנועה
    plt.figure(figsize=(8, 5))
    plt.bar(range(len(rom_values)), rom_values, color='b', alpha=0.7, label='ROM per Pulse')
    plt.axhline(rom_mean, color='r', linestyle='--', label=f'Average ROM: {rom_mean:.2f} cm')
    plt.xlabel("Pulse Index")
    plt.ylabel("Range of Motion (cm)")
    plt.title(f'Range of Motion (ROM) per Pulse - {file}')
    plt.legend()
    plt.show()

# הצגת תוצאות ב-DataFrame
df_rom = pd.DataFrame(rom_results)
print(df_rom)

# הצגת גרף מסכם לכל הקבצים
plt.figure(figsize=(8, 5))
for result in rom_results:
    plt.bar(result["File"], result["Mean ROM"], yerr=result["Std ROM"], capsize=5, label=result["File"])
plt.xlabel("File")
plt.ylabel("Mean ROM (cm)")
plt.title("Summary of ROM for Different Pulse Intensities")
plt.legend()
plt.show()

"""# New Section"""

import scipy.io
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# רשימת קובצי ה-MAT
mat_files = [
    "ayelet_25v.mat",
    "ayelet_30v.mat",
    "ayelet_35v.mat",
    "ayelet_40v.mat"
]

# קצב הדגימה (הנחה: 1000 דגימות לשנייה)
sampling_rate = 1000  # 1000 Hz

# חלון זמן לסגמנטציה
pre_pulse = int(0.1 * sampling_rate)  # 100 מילישניות לפני
post_pulse = int(0.4 * sampling_rate)  # 400 מילישניות אחרי

# משתנה לאחסון תוצאות ROM מכל הקבצים
rom_results = []
mean_responses = {}

for file in mat_files:
    # טעינת נתוני הקובץ
    mat_data = scipy.io.loadmat(file)
    data = mat_data['data']
    labels = mat_data['labels']

    # זיהוי ערוצי המדידה
    finger_displacement_idx = np.where(labels == 'Finger Displacement')[0][0]
    analog_input_idx = np.where(labels == 'Analog input')[0][0]

    # נתוני המדידה
    analog_signal = data[:, analog_input_idx]
    finger_signal = data[:, finger_displacement_idx]

    # זיהוי רגעי הפולסים
    threshold = np.mean(analog_signal) + 3 * np.std(analog_signal)
    pulse_starts = np.where((analog_signal[:-1] < threshold) & (analog_signal[1:] >= threshold))[0]

    # יצירת מקטעים סביב הפולסים
    segments = []
    for start in pulse_starts:
        if start - pre_pulse >= 0 and start + post_pulse < len(finger_signal):
            segments.append(finger_signal[start - pre_pulse:start + post_pulse])

    segments = np.array(segments)

    # חישוב ממוצע וסטיית תקן של הסגמנטים
    mean_response = np.mean(segments, axis=0)
    std_response = np.std(segments, axis=0)

    # שמירת ממוצע התגובה לכל קובץ
    mean_responses[file] = mean_response

    # חישוב ROM לכל פולס
    rom_values = np.max(segments, axis=1) - np.min(segments, axis=1)
    rom_mean = np.mean(rom_values)
    rom_std = np.std(rom_values)

    # שמירת הנתונים עבור הקובץ
    rom_results.append({"File": file, "Mean ROM": rom_mean, "Std ROM": rom_std, "Num Pulses": len(pulse_starts)})

# יצירת גרף ממוצע התגובות עבור ayelet_25v ו-ayelet_40
plt.figure(figsize=(8, 5))
time_axis = np.linspace(-100, 400, pre_pulse + post_pulse)
plt.plot(time_axis, mean_responses["ayelet_25v.mat"], label='ayelet_25v', color='b')
plt.plot(time_axis, mean_responses["ayelet_40v.mat"], label='ayelet_40v', color='g')
plt.axvline(0, color='r', linestyle='--', label='Pulse Start')
plt.xlabel('Time (ms)')
plt.ylabel('Finger Displacement (cm)')
plt.title('Comparison of Average Finger Twitch Response')
plt.legend()
plt.show()

# גרף נוסף: שתי העקומות מתחילות יחד על 0 בציר ה-Y
plt.figure(figsize=(8, 5))
adjusted_25v = mean_responses["ayelet_25v.mat"] - mean_responses["ayelet_25v.mat"][0]
adjusted_40v = mean_responses["ayelet_40v.mat"] - mean_responses["ayelet_40v.mat"][0]
plt.plot(time_axis, adjusted_25v, label='ayelet_25v', color='b')
plt.plot(time_axis, adjusted_40v, label='ayelet_40v', color='g')
plt.axvline(0, color='r', linestyle='--', label='Pulse Start')
plt.xlabel('Time (ms)')
plt.ylabel('Finger Displacement (cm)')
plt.title('Comparison of Average Finger Twitch Response (Aligned to Zero)')
plt.legend()
# התאמת ציר ה-Y
plt.yticks(np.arange(0, 1.61, 0.2))
plt.ylim(0, 1.6)
plt.show()

import scipy.io
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# רשימת קובצי ה-MAT
mat_files = [
    "zohar_25v.mat",
    "zohar_30v.mat",
    "zohar_35v.mat",
    "zohar_40v.mat"
]

# קצב הדגימה (2000 דגימות לשנייה)
sampling_rate = 2000  # 2000 Hz

# חלון זמן לסגמנטציה
pre_pulse = int(0.1 * sampling_rate)  # 100 מילישניות לפני
post_pulse = int(0.4 * sampling_rate)  # 400 מילישניות אחרי

# משתנה לאחסון תוצאות ROM מכל הקבצים
rom_results = []

for file in mat_files:
    # טעינת נתוני הקובץ
    mat_data = scipy.io.loadmat(file)
    data = mat_data['data']
    labels = mat_data['labels']

    # זיהוי ערוצי המדידה
    finger_displacement_idx = np.where(labels == 'Finger Displacement')[0][0]
    emg_idx = np.where(labels == 'EMG (5 - 500 Hz)')[0][0]

    # נתוני המדידה
    emg_signal = data[:, emg_idx]
    finger_signal = data[:, finger_displacement_idx]

    # זיהוי רגעי הפולסים
    threshold = np.mean(emg_signal) + 3 * np.std(emg_signal)
    pulse_starts = np.where((emg_signal[:-1] < threshold) & (emg_signal[1:] >= threshold))[0]

    # יצירת מקטעים סביב הפולסים
    segments = []
    for start in pulse_starts:
        if start - pre_pulse >= 0 and start + post_pulse < len(finger_signal):
            segments.append(finger_signal[start - pre_pulse:start + post_pulse])

    segments = np.array(segments)

    # חישוב ממוצע וסטיית תקן של הסגמנטים
    mean_response = np.mean(segments, axis=0)
    std_response = np.std(segments, axis=0)

    # חישוב ROM לכל פולס (הפרש בין הערך המקסימלי לערך 100ms לפני הגירוי)
    rom_values = np.max(segments, axis=1) - segments[:, pre_pulse]
    rom_mean = np.mean(rom_values)
    rom_std = np.std(rom_values)

    # שמירת הנתונים עבור הקובץ
    rom_results.append({"File": file, "Mean ROM": rom_mean, "Std ROM": rom_std, "Num Pulses": len(pulse_starts)})

    # יצירת גרף של ממוצע התגובה
    time_axis = np.linspace(-100, 400, pre_pulse + post_pulse)
    plt.figure(figsize=(8, 5))
    plt.plot(time_axis, mean_response, label='Mean Response', color='b')
    plt.fill_between(time_axis, mean_response - std_response, mean_response + std_response, color='b', alpha=0.2)
    plt.axvline(0, color='r', linestyle='--', label='Pulse Start')
    plt.xlabel('Time (ms)')
    plt.ylabel('Finger Displacement (cm)')
    plt.title(f'Average Finger Twitch Response - {file}')
    plt.legend()
    plt.show()

    # יצירת גרף של טווחי התנועה
    plt.figure(figsize=(8, 5))
    plt.bar(range(len(rom_values)), rom_values, color='b', alpha=0.7, label='ROM per Pulse')
    plt.axhline(rom_mean, color='r', linestyle='--', label=f'Average ROM: {rom_mean:.2f} cm')
    plt.xlabel("Pulse Index")
    plt.ylabel("Range of Motion (cm)")
    plt.title(f'Range of Motion (ROM) per Pulse - {file}')
    plt.legend()
    plt.show()

# הצגת תוצאות ב-DataFrame
df_rom = pd.DataFrame(rom_results)
print(df_rom)

# הצגת גרף מסכם לכל הקבצים
plt.figure(figsize=(8, 5))
for result in rom_results:
    plt.bar(result["File"], result["Mean ROM"], yerr=result["Std ROM"], capsize=5, label=result["File"])
plt.xlabel("File")
plt.ylabel("Mean ROM (cm)")
plt.title("Summary of ROM for Different Pulse Intensities")
plt.legend()
plt.show()

import scipy.io
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# רשימת קובצי ה-MAT
mat_files = [
    "zohar_25v.mat",
    "zohar_30v.mat",
    "zohar_35v.mat",
    "zohar_40v.mat"
]

# קצב הדגימה (2000 דגימות לשנייה)
sampling_rate = 2000  # 2000 Hz

# חלון זמן לסגמנטציה
pre_pulse = int(0.1 * sampling_rate)  # 100 מילישניות לפני
post_pulse = int(0.4 * sampling_rate)  # 400 מילישניות אחרי

# משתנה לאחסון תוצאות ROM מכל הקבצים
rom_results = []
mean_responses = {}

for file in mat_files:
    # טעינת נתוני הקובץ
    mat_data = scipy.io.loadmat(file)
    data = mat_data['data']
    labels = mat_data['labels']

    # זיהוי ערוצי המדידה
    finger_displacement_idx = np.where(labels == 'Finger Displacement')[0][0]
    emg_idx = np.where(labels == 'EMG (5 - 500 Hz)')[0][0]

    # נתוני המדידה
    emg_signal = data[:, emg_idx]
    finger_signal = data[:, finger_displacement_idx]

    # זיהוי רגעי הפולסים
    threshold = np.mean(emg_signal) + 3 * np.std(emg_signal)
    pulse_starts = np.where((emg_signal[:-1] < threshold) & (emg_signal[1:] >= threshold))[0]

    # יצירת מקטעים סביב הפולסים
    segments = []
    for start in pulse_starts:
        if start - pre_pulse >= 0 and start + post_pulse < len(finger_signal):
            segments.append(finger_signal[start - pre_pulse:start + post_pulse])

    segments = np.array(segments)

    # חישוב ממוצע וסטיית תקן של הסגמנטים
    mean_response = np.mean(segments, axis=0)
    std_response = np.std(segments, axis=0)

    # שמירת ממוצע התגובה לכל קובץ
    mean_responses[file] = mean_response

    # חישוב ROM לכל פולס
    rom_values = np.max(segments, axis=1) - np.min(segments, axis=1)
    rom_mean = np.mean(rom_values)
    rom_std = np.std(rom_values)

    # שמירת הנתונים עבור הקובץ
    rom_results.append({"File": file, "Mean ROM": rom_mean, "Std ROM": rom_std, "Num Pulses": len(pulse_starts)})

# יצירת גרף ממוצע התגובות עבור zohar_25v ו-zohar_40
plt.figure(figsize=(8, 5))
time_axis = np.linspace(-100, 400, pre_pulse + post_pulse)
plt.plot(time_axis, mean_responses["zohar_25v.mat"], label='zohar_25v', color='b')
plt.plot(time_axis, mean_responses["zohar_40v.mat"], label='zohar_40v', color='g')
plt.axvline(0, color='r', linestyle='--', label='Pulse Start')
plt.xlabel('Time (ms)')
plt.ylabel('Finger Displacement (cm)')
plt.title('Comparison of Average Finger Twitch Response')
plt.legend()
plt.show()

# גרף נוסף: שתי העקומות מתחילות יחד על 0 בציר ה-Y
plt.figure(figsize=(8, 5))
adjusted_25v = mean_responses["zohar_25v.mat"] - mean_responses["zohar_25v.mat"][0]
adjusted_40v = mean_responses["zohar_40v.mat"] - mean_responses["zohar_40v.mat"][0]
plt.plot(time_axis, adjusted_25v, label='zohar_25v', color='b')
plt.plot(time_axis, adjusted_40v, label='zohar_40v', color='g')
plt.axvline(0, color='r', linestyle='--', label='Pulse Start')
plt.xlabel('Time (ms)')
plt.ylabel('Finger Displacement (cm)')
plt.title('Comparison of Average Finger Twitch Response (Aligned to Zero)')
plt.legend()
# התאמת ציר ה-Y
plt.yticks(np.arange(0, 5.1, 1))
plt.ylim(0, 5)
plt.show()

"""ניסוי 2"""

import scipy.io
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# רשימת קובצי ה-MAT
mat_files = [
    "ayelet_0.1ms.mat",
    "ayelet_0.15ms.mat",
    "ayelet_0.2ms.mat",
    "ayelet_0.25ms.mat"
]

# קצב הדגימה (הנחה: 2000 דגימות לשנייה)
sampling_rate = 2000  # 2000 Hz

# חלון זמן לסגמנטציה
pre_pulse = int(0.1 * sampling_rate)  # 100 מילישניות לפני הגירוי
post_pulse = int(0.4 * sampling_rate)  # 400 מילישניות אחרי הגירוי

# משתנה לאחסון תוצאות ROM מכל הקבצים
rom_results = []

for file in mat_files:
    # טעינת נתוני הקובץ
    mat_data = scipy.io.loadmat(file)
    data = mat_data['data']
    labels = mat_data['labels']

    # זיהוי ערוצי המדידה
    finger_displacement_idx = np.where(labels == 'Finger Displacement')[0][0]
    analog_input_idx = np.where(labels == 'Analog input')[0][0]

    # נתוני המדידה
    analog_signal = data[:, analog_input_idx]
    finger_signal = data[:, finger_displacement_idx]

    # זיהוי רגעי הפולסים
    threshold = np.mean(analog_signal) + 3 * np.std(analog_signal)
    pulse_starts = np.where((analog_signal[:-1] < threshold) & (analog_signal[1:] >= threshold))[0]

    # יצירת מקטעים סביב הפולסים
    segments = []
    for start in pulse_starts:
        if start - pre_pulse >= 0 and start + post_pulse < len(finger_signal):
            segments.append(finger_signal[start - pre_pulse:start + post_pulse])

    segments = np.array(segments)

    # חישוב ממוצע וסטיית תקן של הסגמנטים
    mean_response = np.mean(segments, axis=0)
    std_response = np.std(segments, axis=0)

    # חישוב ROM לכל פולס (ההבדל בין הערך המקסימלי לבין הערך ב-100ms לפני הגירוי)
    rom_values = np.max(segments, axis=1) - segments[:, pre_pulse]
    rom_mean = np.mean(rom_values)
    rom_std = np.std(rom_values)

    # שמירת הנתונים עבור הקובץ
    rom_results.append({"File": file, "Mean ROM": rom_mean, "Std ROM": rom_std, "Num Pulses": len(pulse_starts)})

    # יצירת גרף של ממוצע התגובה
    time_axis = np.linspace(-100, 400, pre_pulse + post_pulse)
    plt.figure(figsize=(8, 5))
    plt.plot(time_axis, mean_response, label='Mean Response', color='b')
    plt.fill_between(time_axis, mean_response - std_response, mean_response + std_response, color='b', alpha=0.2)
    plt.axvline(0, color='r', linestyle='--', label='Pulse Start')
    plt.xlabel('Time (ms)')
    plt.ylabel('Finger Displacement (cm)')
    plt.title(f'Average Finger Twitch Response - {file}')
    plt.legend()
    plt.show()

    # יצירת גרף של טווחי התנועה
    plt.figure(figsize=(8, 5))
    plt.bar(range(len(rom_values)), rom_values, color='b', alpha=0.7, label='ROM per Pulse')
    plt.axhline(rom_mean, color='r', linestyle='--', label=f'Average ROM: {rom_mean:.2f} cm')
    plt.xlabel("Pulse Index")
    plt.ylabel("Range of Motion (cm)")
    plt.title(f'Range of Motion (ROM) per Pulse - {file}')
    plt.legend()
    plt.show()

# הצגת תוצאות ב-DataFrame
df_rom = pd.DataFrame(rom_results)
print(df_rom)

# הצגת גרף מסכם לכל הקבצים
plt.figure(figsize=(8, 5))
for result in rom_results:
    plt.bar(result["File"], result["Mean ROM"], yerr=result["Std ROM"], capsize=5, label=result["File"])
plt.xlabel("File")
plt.ylabel("Mean ROM (cm)")
plt.title("Summary of ROM for Different Pulse Duration")
plt.legend()
plt.show()

import scipy.io
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# רשימת קובצי ה-MAT
mat_files = [
    "ayelet_0.1ms.mat",
    "ayelet_0.15ms.mat",
    "ayelet_0.2ms.mat",
    "ayelet_0.25ms.mat"
]

# קצב הדגימה (הנחה: 1000 דגימות לשנייה)
sampling_rate = 1000  # 1000 Hz

# חלון זמן לסגמנטציה
pre_pulse = int(0.1 * sampling_rate)  # 100 מילישניות לפני
post_pulse = int(0.4 * sampling_rate)  # 400 מילישניות אחרי

# משתנה לאחסון תוצאות ROM מכל הקבצים
rom_results = []
mean_responses = {}

for file in mat_files:
    # טעינת נתוני הקובץ
    mat_data = scipy.io.loadmat(file)
    data = mat_data['data']
    labels = mat_data['labels']

    # זיהוי ערוצי המדידה
    finger_displacement_idx = np.where(labels == 'Finger Displacement')[0][0]
    analog_input_idx = np.where(labels == 'Analog input')[0][0]

    # נתוני המדידה
    analog_signal = data[:, analog_input_idx]
    finger_signal = data[:, finger_displacement_idx]

    # זיהוי רגעי הפולסים
    threshold = np.mean(analog_signal) + 3 * np.std(analog_signal)
    pulse_starts = np.where((analog_signal[:-1] < threshold) & (analog_signal[1:] >= threshold))[0]

    # יצירת מקטעים סביב הפולסים
    segments = []
    for start in pulse_starts:
        if start - pre_pulse >= 0 and start + post_pulse < len(finger_signal):
            segments.append(finger_signal[start - pre_pulse:start + post_pulse])

    segments = np.array(segments)

    # חישוב ממוצע וסטיית תקן של הסגמנטים
    mean_response = np.mean(segments, axis=0)
    std_response = np.std(segments, axis=0)

    # שמירת ממוצע התגובה לכל קובץ
    mean_responses[file] = mean_response

    # חישוב ROM לכל פולס
    rom_values = np.max(segments, axis=1) - np.min(segments, axis=1)
    rom_mean = np.mean(rom_values)
    rom_std = np.std(rom_values)

    # שמירת הנתונים עבור הקובץ
    rom_results.append({"File": file, "Mean ROM": rom_mean, "Std ROM": rom_std, "Num Pulses": len(pulse_starts)})

# יצירת גרף ממוצע התגובות עבור ayelet_0.1ms ו-ayelet_0.25ms
plt.figure(figsize=(8, 5))
time_axis = np.linspace(-100, 400, pre_pulse + post_pulse)
plt.plot(time_axis, mean_responses["ayelet_0.1ms.mat"], label='ayelet_0.1ms.mat', color='b')
plt.plot(time_axis, mean_responses["ayelet_0.25ms.mat"], label='ayelet_0.25ms.mat', color='g')
plt.axvline(0, color='r', linestyle='--', label='Pulse Start')
plt.xlabel('Time (ms)')
plt.ylabel('Finger Displacement (cm)')
plt.title('Comparison of Average Finger Twitch Duration')
plt.legend()
plt.show()

# גרף נוסף: שתי העקומות מתחילות יחד על 0 בציר ה-Y
plt.figure(figsize=(8, 5))
adjusted_0_1ms = mean_responses["ayelet_0.1ms.mat"] - mean_responses["ayelet_0.1ms.mat"][0]
adjusted_0_25ms = mean_responses["ayelet_0.25ms.mat"] - mean_responses["ayelet_0.25ms.mat"][0]
plt.plot(time_axis, adjusted_0_1ms, label='ayelet_0.1ms.mat', color='b')
plt.plot(time_axis, adjusted_0_25ms, label='ayelet_0.25ms.mat', color='g')
plt.axvline(0, color='r', linestyle='--', label='Pulse Start')
plt.xlabel('Time (ms)')
plt.ylabel('Finger Displacement (cm)')
plt.title('Comparison of Average Finger Twitch Duration (Aligned to Zero)')
plt.legend()
# התאמת ציר ה-Y
plt.yticks(np.arange(0, 1.51, 0.25))
plt.ylim(0, 1.5)
plt.show()

import scipy.io
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# רשימת קובצי ה-MAT
mat_files = [
    "zohar_0.1ms.mat",
    "zohar_0.2ms.mat",
    "zohar_0.25ms.mat",
    "zohar_0.3ms.mat"
]

# קצב הדגימה (2000 דגימות לשנייה)
sampling_rate = 2000  # 2000 Hz

# חלון זמן לסגמנטציה
pre_pulse = int(0.1 * sampling_rate)  # 100 מילישניות לפני
post_pulse = int(0.4 * sampling_rate)  # 400 מילישניות אחרי

# משתנה לאחסון תוצאות ROM מכל הקבצים
rom_results = []

for file in mat_files:
    # טעינת נתוני הקובץ
    mat_data = scipy.io.loadmat(file)
    data = mat_data['data']
    labels = mat_data['labels']

    # זיהוי ערוצי המדידה
    finger_displacement_idx = np.where(labels == 'Finger Displacement')[0][0]
    emg_idx = np.where(labels == 'EMG (5 - 500 Hz)')[0][0]

    # נתוני המדידה
    emg_signal = data[:, emg_idx]
    finger_signal = data[:, finger_displacement_idx]

    # זיהוי רגעי הפולסים
    threshold = np.mean(emg_signal) + 3 * np.std(emg_signal)
    pulse_starts = np.where((emg_signal[:-1] < threshold) & (emg_signal[1:] >= threshold))[0]

    # יצירת מקטעים סביב הפולסים
    segments = []
    for start in pulse_starts:
        if start - pre_pulse >= 0 and start + post_pulse < len(finger_signal):
            segments.append(finger_signal[start - pre_pulse:start + post_pulse])

    segments = np.array(segments)

    # חישוב ממוצע וסטיית תקן של הסגמנטים
    mean_response = np.mean(segments, axis=0)
    std_response = np.std(segments, axis=0)

    # חישוב ROM לכל פולס (הפרש בין הערך המקסימלי לערך 100ms לפני הגירוי)
    rom_values = np.max(segments, axis=1) - segments[:, pre_pulse]
    rom_mean = np.mean(rom_values)
    rom_std = np.std(rom_values)

    # שמירת הנתונים עבור הקובץ
    rom_results.append({"File": file, "Mean ROM": rom_mean, "Std ROM": rom_std, "Num Pulses": len(pulse_starts)})

    # יצירת גרף של ממוצע התגובה
    time_axis = np.linspace(-100, 400, pre_pulse + post_pulse)
    plt.figure(figsize=(8, 5))
    plt.plot(time_axis, mean_response, label='Mean Response', color='b')
    plt.fill_between(time_axis, mean_response - std_response, mean_response + std_response, color='b', alpha=0.2)
    plt.axvline(0, color='r', linestyle='--', label='Pulse Start')
    plt.xlabel('Time (ms)')
    plt.ylabel('Finger Displacement (cm)')
    plt.title(f'Average Finger Twitch Response - {file}')
    plt.legend()
    plt.show()

    # יצירת גרף של טווחי התנועה
    plt.figure(figsize=(8, 5))
    plt.bar(range(len(rom_values)), rom_values, color='b', alpha=0.7, label='ROM per Pulse')
    plt.axhline(rom_mean, color='r', linestyle='--', label=f'Average ROM: {rom_mean:.2f} cm')
    plt.xlabel("Pulse Index")
    plt.ylabel("Range of Motion (cm)")
    plt.title(f'Range of Motion (ROM) per Pulse - {file}')
    plt.legend()
    plt.show()

# הצגת תוצאות ב-DataFrame
df_rom = pd.DataFrame(rom_results)
print(df_rom)

# הצגת גרף מסכם לכל הקבצים
plt.figure(figsize=(8, 5))
for result in rom_results:
    plt.bar(result["File"], result["Mean ROM"], yerr=result["Std ROM"], capsize=5, label=result["File"])
plt.xlabel("File")
plt.ylabel("Mean ROM (cm)")
plt.title("Summary of ROM for Different Pulse Duration")
plt.legend()
plt.show()

import scipy.io
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# רשימת קובצי ה-MAT
mat_files = [
    "zohar_0.1ms.mat",
    "zohar_0.2ms.mat",
    "zohar_0.25ms.mat",
    "zohar_0.3ms.mat"
]

# קצב הדגימה (2000 דגימות לשנייה)
sampling_rate = 2000  # 2000 Hz

# חלון זמן לסגמנטציה
pre_pulse = int(0.1 * sampling_rate)  # 100 מילישניות לפני
post_pulse = int(0.4 * sampling_rate)  # 400 מילישניות אחרי

# משתנה לאחסון תוצאות ROM מכל הקבצים
rom_results = []
mean_responses = {}

for file in mat_files:
    # טעינת נתוני הקובץ
    mat_data = scipy.io.loadmat(file)
    data = mat_data['data']
    labels = mat_data['labels']

    # זיהוי ערוצי המדידה
    finger_displacement_idx = np.where(labels == 'Finger Displacement')[0][0]
    emg_idx = np.where(labels == 'EMG (5 - 500 Hz)')[0][0]

    # נתוני המדידה
    emg_signal = data[:, emg_idx]
    finger_signal = data[:, finger_displacement_idx]

    # זיהוי רגעי הפולסים
    threshold = np.mean(emg_signal) + 3 * np.std(emg_signal)
    pulse_starts = np.where((emg_signal[:-1] < threshold) & (emg_signal[1:] >= threshold))[0]

    # יצירת מקטעים סביב הפולסים
    segments = []
    for start in pulse_starts:
        if start - pre_pulse >= 0 and start + post_pulse < len(finger_signal):
            segments.append(finger_signal[start - pre_pulse:start + post_pulse])

    segments = np.array(segments)

    # חישוב ממוצע וסטיית תקן של הסגמנטים
    mean_response = np.mean(segments, axis=0)
    std_response = np.std(segments, axis=0)

    # שמירת ממוצע התגובה לכל קובץ
    mean_responses[file] = mean_response

    # חישוב ROM לכל פולס
    rom_values = np.max(segments, axis=1) - np.min(segments, axis=1)
    rom_mean = np.mean(rom_values)
    rom_std = np.std(rom_values)

    # שמירת הנתונים עבור הקובץ
    rom_results.append({"File": file, "Mean ROM": rom_mean, "Std ROM": rom_std, "Num Pulses": len(pulse_starts)})

# יצירת גרף ממוצע התגובות עבור zohar_0.1ms ו-zohar_0.3ms
plt.figure(figsize=(8, 5))
time_axis = np.linspace(-100, 400, pre_pulse + post_pulse)
plt.plot(time_axis, mean_responses["zohar_0.1ms.mat"], label='zohar_0.1ms.mat', color='b')
plt.plot(time_axis, mean_responses["zohar_0.3ms.mat"], label='zohar_0.3ms.mat', color='g')
plt.axvline(0, color='r', linestyle='--', label='Pulse Start')
plt.xlabel('Time (ms)')
plt.ylabel('Finger Displacement (cm)')
plt.title('Comparison of Average Finger Twitch Duration')
plt.legend()
plt.show()

# גרף נוסף: שתי העקומות מתחילות יחד על 0 בציר ה-Y
plt.figure(figsize=(8, 5))
adjusted_0_1ms = mean_responses["zohar_0.1ms.mat"] - mean_responses["zohar_0.1ms.mat"][0]
adjusted_0_3ms = mean_responses["zohar_0.3ms.mat"] - mean_responses["zohar_0.3ms.mat"][0]
plt.plot(time_axis, adjusted_0_1ms, label='zohar_0.1ms.mat', color='b')
plt.plot(time_axis, adjusted_0_3ms, label='zohar_0.3ms.mat', color='g')
plt.axvline(0, color='r', linestyle='--', label='Pulse Start')
plt.xlabel('Time (ms)')
plt.ylabel('Finger Displacement (cm)')
plt.title('Comparison of Average Finger Twitch Duration (Aligned to Zero)')
plt.legend()
# התאמת ציר ה-Y
plt.yticks(np.arange(0, 2.6, 0.5))
plt.ylim(0, 2.5)
plt.show()